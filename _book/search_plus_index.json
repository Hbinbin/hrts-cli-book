{"./":{"url":"./","title":"前言","keywords":"","body":"hrts-cli是react-typescript的脚手架工具 用于快速的构建react-typescript项目，实现零配置且开箱即用。让前端开发只关心业务代码逻辑，而无需关心其他任何配置。 "},"book/introduction.html":{"url":"book/introduction.html","title":"开始","keywords":"","body":"hrts-cli集成了react项目的最佳开发实践 是在create-react-app创建的项目下的二次封装，具体如下： 1. eslint规则 javascript语法规则使用standard react语法规则使用standard-react typescript语法规则使用typescript-eslint 定制化的规则见项目模板的 .eslint.js 文件具体的规则参照对应的插件规则，传送门：standard standard-react typescript-eslint 2. webpack配置 基本沿用 npm run eject后的webpack配置，详细配置见：前言章节 3. 集成的插件 antd/antd-mobile UI框架 axios HTTP库 immutability-helper 更好的操作不可变数据的插件，例如redux修改state，修改深层嵌套的数据时 reselect redux的中间件，缓存redux的数据，减少计算和渲染压力 传送门：antd antd-mobile axios immutability-helper reselect "},"book/template/template.html":{"url":"book/template/template.html","title":"模板架构","keywords":"","body":"介绍模板的基本文件结构 统一的项目目录，更易于不同的开发人员快速的了解项目结构以及定位代码模块 文件结构 "},"book/template/file-structure.html":{"url":"book/template/file-structure.html","title":"文件结构","keywords":"","body":"模板的基本文件结构 所有网络请求的api集中的文件夹，具体的写法可参照模板里的use.api.ts文件 // use.api.ts export default class UserAPI { /** 获取用户信息API */ private static readonly USER_API = 'IAccountRoles/getUser'; /** * 获取用户信息 * @static * @param {string} mobile - 用户手机号 */ static async getUser ({ mobile }: IGetUserParams) { const url = 'xxxx' + this.USER_API; const params = { mobile }; return axios.post(url, params); } } 所有的api可集中在api/index.ts中集中输出 // index.ts export { default as UserAPI } from './user.api'; ...other api 参考文件结构： 所有样式、图片、字体集中的地方 css common（公共组件样式文件夹）index.scss（公共组件样式在此集中输出）some-common-component.scss index.scss（所有组件样式在此集中输出） some-component.scss iconfont（图标、字体文件） images（图片） 参考文件结构： 全局配置，全局方法集中在此文件夹全局常量集中存储在config.ts // config.ts export default class Config { /** 当前渠道 */ static readonly CHANNEL = 'mall' } window.Config = Config; 注：要想在window上访问window.Config还需在入口文件引入以及在react-app-env.d.ts中加入以下代码： interface Window { __REDUX_DEVTOOLS_EXTENSION__: Function; __wxjs_environment: 'miniprogram' | 'browser'; Config: any; } 参考文件结构： 组件集中的地方此处的文件规范应该是比较灵活的，根据不同的项目可自行搭配，如手机商城项目会根据底部的tabbar分为三个模块文件夹，每个模块有index.tsx文件来管理router common（公共组件文件夹） index.ts（公共组件在此集中输出） SomeCommonComponent.tsx component1（组件component1文件夹） component1.tsx component2（组件component2文件夹） component2.tsx index.tsx（在此处可做路由router的管理） 参考文件结构： redux状态管理文件集中管理的地方 rootReducer.ts（所有reducer集中combine的文件） selector.ts（selector方法集中的地方） other.redux.ts 参考文件结构： 所有typescript接口 具体的实用语法在typescript语法章节介绍 参考文件结构： 工具方法集中的地方 "},"book/typescript/typescript.html":{"url":"book/typescript/typescript.html","title":"实用的typescript特性","keywords":"","body":"TypeScript的基本语法 在window增加属性 // 方法1：react-app-env.d.ts中直接增加window的接口（推荐） interface Window { __REDUX_DEVTOOLS_EXTENSION__: Function; __wxjs_environment: 'miniprogram' | 'browser'; ENV: any; Config: any; } // 方法2：index.tsx中增加全局window属性 declare global { interface Window { __REDUX_DEVTOOLS_EXTENSION__: Function; __wxjs_environment: any; ENV: any; Config: any; } } 对于插件没有ts包的 // 在react-app-env.d.ts中增加 declare module 'react-lazy-load' { const LazyLoad: any export default LazyLoad } 匿名函数的this // 回调中直接使用this会报错 'this 隐式具有类型 any，因为它没有类型注释' // this必须作为回调的第一个参数传入，类型为：void | any ele.addEventListener('touchmove', function(this: any,evt: any) { console.log(this); }) 对象、数组对象的表示 const obj: { [key: string]: any } = {} const arrObj: { [key: string]: any }[] = [] setState interface IState{ property1: string; } type StateKey = keyof IState handleChange = (key: StateKey, val: any) => { this.setState({ [key]: val } as Pick) } "},"book/webpack/webpack.html":{"url":"book/webpack/webpack.html","title":"webpack配置","keywords":"","body":"TypeScript的基本语法 在window增加属性 // 方法1：react-app-env.d.ts中直接增加window的接口（推荐） interface Window { __REDUX_DEVTOOLS_EXTENSION__: Function; __wxjs_environment: 'miniprogram' | 'browser'; ENV: any; Config: any; } // 方法2：index.tsx中增加全局window属性 declare global { interface Window { __REDUX_DEVTOOLS_EXTENSION__: Function; __wxjs_environment: any; ENV: any; Config: any; } } 对于插件没有ts包的 // 在react-app-env.d.ts中增加 declare module 'react-lazy-load' { const LazyLoad: any export default LazyLoad } 匿名函数的this // 回调中直接使用this会报错 'this 隐式具有类型 any，因为它没有类型注释' // this必须作为回调的第一个参数传入，类型为：void | any ele.addEventListener('touchmove', function(this: any,evt: any) { console.log(this); }) 对象、数组对象的表示 const obj: { [key: string]: any } = {} const arrObj: { [key: string]: any }[] = [] setState type StateKey = keyof IState handleChange = (key: StateKey, val: any) => { this.setState({ [key]: val } as Pick) } "}}