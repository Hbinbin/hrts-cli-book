{"./":{"url":"./","title":"前言","keywords":"","body":"hrts-cli是react-typescript的脚手架工具 用于快速的构建react-typescript项目，实现零配置且开箱即用。让前端开发只关心业务代码逻辑，而无需关心其他任何配置。 hrts-cli集成了react项目的最佳开发实践 是在create-react-app创建的项目下的二次封装，具体如下： 1. eslint规则 javascript语法规则使用standard react语法规则使用standard-react typescript语法规则使用typescript-eslint 定制化的规则见项目模板的 .eslint.js 文件具体的规则参照对应的插件规则，传送门：standard standard-react typescript-eslint 2. webpack配置 基本沿用 npm run eject后的webpack配置，详细配置见：webpack配置章节 3. 集成的插件 antd/antd-mobile UI框架 axios HTTP库 immutability-helper 更好的操作不可变数据的插件，例如redux修改state，修改深层嵌套的数据时 reselect redux的中间件，缓存redux的数据，减少计算和渲染压力 传送门：antd antd-mobile axios immutability-helper reselect "},"book/start.html":{"url":"book/start.html","title":"开始","keywords":"","body":"1.安装hrts-cli脚手架工具 全局安装hrts-cli npm i hrts-cli -g 2.新建项目 初始化项目模板 hrts-cli init [项目名称] 3.安装依赖、启动项目 mac终端执行 sh init.start.sh 或 npm i npm start 4.编辑器设置（vscode） 代码保存自动修复的配置：修改vscode的配置文件 settings.json // 增加需要自动修复的语言 \"eslint.validate\": [ ... \"html\", \"javascript\", \"react\", \"typescript\", \"typescriptreact\", ... ], // 开启自动修复 \"eslint.autoFixOnSave\": true,（此设置已废弃） 此项已修改为： \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true }, 注：配置完不生效时，请重启编辑器、重启项目 "},"book/template/template.html":{"url":"book/template/template.html","title":"模板架构","keywords":"","body":"介绍模板的基本文件结构 统一的项目目录，更易于不同的开发人员快速的了解项目结构以及定位代码模块 文件结构 "},"book/template/file-structure.html":{"url":"book/template/file-structure.html","title":"文件结构","keywords":"","body":"模板的基本文件结构 所有网络请求的api集中的文件夹具体的写法可参照模板里的src/api/user.api.ts文件： export default class UserAPI { /** 获取用户信息API */ private static readonly USER_API = 'IAccountRoles/getUser'; /** * 获取用户信息 * @static * @param {string} mobile - 用户手机号 */ static async getUser ({ mobile }: IGetUserParams) { const url = 'xxxx' + this.USER_API; const params = { mobile }; return axios.post(url, params); } } 所有的api可集中在src/api/index.ts中集中输出： export { default as UserAPI } from './user.api'; ...other api 参考文件结构： 所有样式、图片、字体集中的地方 css common（公共组件样式文件夹）index.scss（公共组件样式在此集中输出）some-common-component.scss index.scss（所有组件样式在此集中输出） some-component.scss iconfont（图标、字体文件） images（图片） 参考文件结构： 全局配置，全局方法集中在此文件夹全局常量、方法集中存储在src/common/config.ts： /** 项目全局配置 */ export default class Config implements IConfig { /** 开发环境 */ static readonly ENV = 'dev'; /** 当前渠道 */ static readonly CHANNEL = 'mall'; } window.Config = Config; 注：要想在window上访问window.Config或全局访问Config，参考：实用的typescript特性章节 参考文件结构： 组件集中的文件夹此处的文件规范应该是比较灵活的，根据不同的项目可自行搭配，如手机商城项目会根据底部的tabbar分为三个模块文件夹，每个模块有index.tsx文件来管理router common（公共组件文件夹） index.ts（公共组件在此集中输出） SomeCommonComponent.tsx component1（组件component1文件夹） component1.tsx component2（组件component2文件夹） component2.tsx index.tsx（在此处可做路由router的管理） 参考文件结构： redux状态管理文件集中管理的文件夹 rootReducer.ts（所有reducer集中combine的文件） selector.ts（selector方法集中的地方） other.redux.ts 参考文件结构： typescript接口集中管理的文件夹 具体的实用语法在实用的typescript特性章节介绍 方式1：通过模块的方式，全局访问接口（推荐） src/typings/api.d.ts定义一个接口： interface IGetUserParams { mobile: string; } src/typings/index.d.ts集中引入模块： /// /// /// interface Window { __REDUX_DEVTOOLS_EXTENSION__: Function; __wxjs_environment: any; ENV: any; Config: IConfig; } declare const Config: IConfig; declare const ENV: any; src/tsconfig.json的include选项增加配置： \"include\": [ \"src\", \"src/typings/index.d.ts\" ] 参考文件结构： 方式2：定义不同的接口文件.ts 在需要类型的地方import引入 src/typings/api.typings.ts定义一个接口： export interface IGetUserParams { mobile: string; } src/typings/user.api.ts引入并使用接口： import { IGetUserParams } from '@typings'; export default class UserAPI { ...some code static async getUser ({ mobile }: IGetUserParams) { ... some code } } 参考文件结构： 工具方法集中的地方 "},"book/typescript/typescript.html":{"url":"book/typescript/typescript.html","title":"实用的typescript特性","keywords":"","body":"TypeScript的实用语法 1. 在window增加属性 方法1：在src/typings/index.d.ts或react-app-env.d.ts中直接增加window的接口（推荐） src/typings/index.d.ts /// /// /// // 增加此Window接口，此时可通过**window.Config**访问 interface Window { __REDUX_DEVTOOLS_EXTENSION__: Function; __wxjs_environment: any; ENV: any; Config: IConfig; } // 声明全局变量Config，此时可直接通过 Config 访问 declare const Config: IConfig; 在src/index.tsx中引入全局配置，给Config赋值 import '@common/config'; // 全局配置 console.log(Config)直接全局访问 方法2：src/index.tsx中增加全局window声明 declare global { interface Window { __REDUX_DEVTOOLS_EXTENSION__: Function; __wxjs_environment: any; ENV: any; Config: any; } } 2. 对于插件没有ts包的 // 在react-app-env.d.ts中增加 declare module 'react-lazy-load' { const LazyLoad: any export default LazyLoad } 3. 匿名函数的this 回调中直接使用this会报错 'this 隐式具有类型 any，因为它没有类型注释' 方法1：this必须作为回调的第一个参数传入，类型为：void | any ele.addEventListener('touchmove', function(this: any,evt: any) { console.log(this); }) 方法2：tsconfig.js增加配置 \"noImplicitThis\": false 4. setState如何使用属性名表达式赋值 interface IState{ } type StateKey = keyof IState handleChange = (key: StateKey, val: any) => { this.setState({ [key]: val } as Pick) } 5. 对象、数组对象的表示 const obj: { [key: string]: any } = {} const arrObj: { [key: string]: any }[] = [] "},"book/webpack/webpack.html":{"url":"book/webpack/webpack.html","title":"webpack配置","keywords":"","body":"1. 配置模块的别名alias 在src/config/webpack.config.js中增加方法和alias配置 const resolvePath = function (dir) { return path.join(__dirname, '..', dir) } ... alias: { // 增加如下配置 '@cps': resolvePath('/src/components'), '@redux': resolvePath('/src/redux'), '@utils': resolvePath('/src/utils') } ... 在src/tscongfig.json文件中compilerOptions中加如下配置 ... \"baseUrl\": \"src\", \"paths\": { \"@cps/*\": [ \"components/*\" ], \"@redux/*\": [ \"redux/*\" ], \"@utils/*\": [ \"utils/*\" ] } 2. 配置多页面入口 3. webpack生产打包去除console、debugger webpack之前的打包压缩插件是uglifyjs-webpack-plugin，现在换成了terser-webpack-plugin修改文件：src/config/webpack.config.js new TerserPlugin({ terserOptions: { ...somecode compress: { ecma: 5, warnings: false, comparisons: false, inline: 2, drop_debugger: true, // 去除所有的debugger drop_console: true // 去除所有的console }, ...somecode }, 4. webpack打包去除.map文件 修改文件src/config/webpack.config.js中的devtool配置 devtool: isEnvProduction ? shouldUseSourceMap ? 'source-map' : false : isEnvDevelopment && 'cheap-module-source-map' 改为： devtool: isEnvProduction ? false : isEnvDevelopment && 'cheap-module-source-map' "},"book/other.html":{"url":"book/other.html","title":"其他","keywords":"","body":"1. vconsole调试插件的引入 安装vconsole npm i vconsole --save-dev 在入口文件index.tsx中import且创建vcosole实例 import VConsole from 'vconsole' const vConsole = new VConsole() 在typescript中引入会报找不到对应ts的模块，在react-app-env.d.ts中增加全局声明: declare module 'vconsole' "},"book/other/react-lazy.html":{"url":"book/other/react-lazy.html","title":"代码分割与路由","keywords":"","body":"代码分割与路由 之前模块代码分割、代码的动态引入需要插件如：react-loadable，或者使用import()，在react16.8版本后可以使用React.lazy()，下面展示结合react-router的代码分割： routeConfig.ts const MallHome = React.lazy(() => import('@cps/mallHome')) const MallCart = React.lazy(() => import('@cps/mallCart')) const MallUser = React.lazy(() => import('@cps/mallUser')) const routes = [ { path: '/mall', component: MallHome }, { path: '/cart', component: MallCart }, { path: '/user', component: MallUser } ] 入口： } /> { routes.map((route, i) => { return ( ( )} /> ) }) } "},"book/other/vconsole.html":{"url":"book/other/vconsole.html","title":"vconsole","keywords":"","body":"vconsole插件的使用 用于手机端H5调试 安装vconsole npm i vconsole --save-dev 在入口文件index.tsx中import且创建vcosole实例 import VConsole from 'vconsole' const vConsole = new VConsole() 在typescript中引入会报找不到对应ts的模块，在react-app-env.d.ts中增加全局声明: declare module 'vconsole' 直接使用 var vConsole = new VConsole(); "}}